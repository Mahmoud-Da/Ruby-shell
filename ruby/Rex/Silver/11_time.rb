# 28
# 次のコードを実行するとどうなりますか

arr = (1..30).to_a
container = []

arr.each_cons(7) do |i|
  container << i
end

p container.length
# 選択
# 選択肢 => ✅
24と表示される

# 選択肢
5と表示される

# 選択肢
7と表示される

# 選択肢
0と表示される


# Memo
p container
[[1, 2, 3, 4, 5, 6, 7],
 [2, 3, 4, 5, 6, 7, 8],
 [3, 4, 5, 6, 7, 8, 9],
 [4, 5, 6, 7, 8, 9, 10],
 [5, 6, 7, 8, 9, 10, 11],
 [6, 7, 8, 9, 10, 11, 12],
 [7, 8, 9, 10, 11, 12, 13],
 [8, 9, 10, 11, 12, 13, 14],
 [9, 10, 11, 12, 13, 14, 15],
 [10, 11, 12, 13, 14, 15, 16],
 [11, 12, 13, 14, 15, 16, 17],
 [12, 13, 14, 15, 16, 17, 18],
 [13, 14, 15, 16, 17, 18, 19],
 [14, 15, 16, 17, 18, 19, 20],
 [15, 16, 17, 18, 19, 20, 21],
 [16, 17, 18, 19, 20, 21, 22],
 [17, 18, 19, 20, 21, 22, 23],
 [18, 19, 20, 21, 22, 23, 24],
 [19, 20, 21, 22, 23, 24, 25],
 [20, 21, 22, 23, 24, 25, 26],
 [21, 22, 23, 24, 25, 26, 27],
 [22, 23, 24, 25, 26, 27, 28],
 [23, 24, 25, 26, 27, 28, 29],
 [24, 25, 26, 27, 28, 29, 30]]



 # 次のプログラムを実行すると何が表示されますか

p "Apple-Banana-Lemon".split /(-)/
# 選択
# 選択肢
"Apple-Banana-Lemon"
# 選択肢
["Apple-Banana-Lemon"]
# 選択肢
["Apple", "Banana", "Lemon"]
# 選択肢 => ✅
["Apple", "-", "Banana", "-", "Lemon"]


# Memo
p "Apple-Banana-Lemon".split /-/ =>  ["Apple", "Banana", "Lemon"]

# split Method
# 第 1 引数 sep で指定されたセパレータによって文字列を limit 個まで分割し、結果を文字列の配列で返します。ブロックを指定すると、配列を返す代わりに分割した文字列でブロックを呼び出します。

# 第 1 引数 sep は以下のいずれかです。

# 正規表現
# 正規表現にマッチする部分で分割する。特に、括弧によるグルーピングがあればそのグループにマッチした文字列も結果の配列に含まれる (後述)。
p "   a \t  b \n  c".split(/\s+/) # => ["", "a", "b", "c"]

p "   a \t  b \n  c".split(nil)   # => ["a", "b", "c"]
p "   a \t  b \n  c".split(' ')   # => ["a", "b", "c"]   # split(nil) と同じ
p "   a \t  b \n  c".split        # => ["a", "b", "c"]   # split(nil) と同じ
p "   a \t  b \n  c".split(/\s+/) # => ["", "a", "b", "c"]

p "   a \t  b \n  c".split(nil)   # => ["a", "b", "c"]
p "   a \t  b \n  c".split(' ')   # => ["a", "b", "c"]   # split(nil) と同じ
p "   a \t  b \n  c".split        # => ["a", "b", "c"]   # split(nil) と同じ

# 括弧を含む正規表現

p '1-10,20'.split(/([-,])/)   # => ["1", "-", "10", ",", "20"]
p '1-10,20'.split(/([-,])/)   # => ["1", "-", "10", ",", "20"]

# 正規表現が空文字列にマッチする場合は 1 文字に分割

p 'hi there'.split(/\s*/).join(':')  # => "h:i:t:h:e:r:e"
p 'hi there'.split(/\s*/).join(':')  # => "h:i:t:h:e:r:e"

# 文字列全体を 1 文字ずつに分割する例

p 'hi there'.split(//).join(':')     # => "h:i: :t:h:e:r:e"
p 'hi there'.split(//).join(':')     # => "h:i: :t:h:e:r:e"

# limit == 0 だと制限なく分割、配列末尾の空文字列は取り除かれる

p "a,b,c,,,".split(/,/, 0)   # => ["a", "b", "c"]
p "a,b,c,,,".split(/,/, 0)   # => ["a", "b", "c"]

# limit 省略時は 0 と同じ (最もよく使われるパターン)

p "a,b,c,,,".split(/,/)      # => ["a", "b", "c"]
p "a,b,c,,,".split(/,/)      # => ["a", "b", "c"]

# 正の limit 使用例

p "a,b,c,d,e".split(/,/, 1)  # => ["a,b,c,d,e"]
p "a,b,c,d,e".split(/,/, 2)  # => ["a", "b,c,d,e"]
p "a,b,c,d,e".split(/,/, 3)  # => ["a", "b", "c,d,e"]
p "a,b,c,d,e".split(/,/, 4)  # => ["a", "b", "c", "d,e"]
p "a,b,c,d,e".split(/,/, 5)  # => ["a", "b", "c", "d", "e"]
p "a,b,c,d,e".split(/,/, 6)  # => ["a", "b", "c", "d", "e"]
p "a,b,c,d,e".split(/,/, 7)  # => ["a", "b", "c", "d", "e"]
p "a,b,c,d,e".split(/,/, 1)  # => ["a,b,c,d,e"]
p "a,b,c,d,e".split(/,/, 2)  # => ["a", "b,c,d,e"]
p "a,b,c,d,e".split(/,/, 3)  # => ["a", "b", "c,d,e"]
p "a,b,c,d,e".split(/,/, 4)  # => ["a", "b", "c", "d,e"]
p "a,b,c,d,e".split(/,/, 5)  # => ["a", "b", "c", "d", "e"]
p "a,b,c,d,e".split(/,/, 6)  # => ["a", "b", "c", "d", "e"]
p "a,b,c,d,e".split(/,/, 7)  # => ["a", "b", "c", "d", "e"]

# limit が負の数の場合は制限なく分割

p "a,b,c,,,".split(/,/, -1)    # => ["a", "b", "c", "", "", ""]





#47
# 次のコードを実行するとどうなりますか

(10..15).to_a.map.with_index(1) do |elem, i|
  puts i
end
# 選択肢  => ✅
1
2
3
4
5
6
# 選択肢
0
1
2
3
4
5
# 選択肢
6
5
4
3
2
1
# 選択肢
5
4
3
2
1
0

# Memo
map.with_index
配列などの要素にindexを添えることができるメソッド

[100, 200, 300].map.with_index do |n, idx|
  p [n, idx]
end

#=>  [[100, 0], [200, 1], [300, 2]]


with_index(1)で指定の数字からカウントできる
[100, 200, 300].map.with_index(1) do |n, idx|
  p [n, idx]
end

#=>  [[100, 1], [200, 2], [300, 3]]


each_with_index
[100, 200, 300].each_with_index do |n, idx|
  p [n, idx]
end
# => [100, 0]
#    [200, 1]
#    [300, 2]


